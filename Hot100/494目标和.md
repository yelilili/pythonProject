###[494. 目标和](https://leetcode-cn.com/problems/target-sum/)
给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。   
示例： 

输入：nums: [1, 1, 1, 1, 1], S: 3
输出：5
-1+1+1+1+1 = 3  
+1-1+1+1+1 = 3  
+1+1-1+1+1 = 3  
+1+1+1-1+1 = 3  
+1+1+1+1-1 = 3

这是一道动态规划的题目，和背包类似对数组nums中的数字进行操作时，每个数+，—两个选择，都只能对应两个路径，举例来说，若当前数字为3，那么，得到和为3的来源只有0和6（0+3=3）（6-3=3）

---动态规划题目四要素---：    
1>dp定义，维度,长度    
2>dp初始化     
3>dp状态转移  
4>判空

1>dp二维数组，长度本应为给出的所有数字之和sum，由于存在加减两种操作，所以dp长度为```2*sum+1```，（-sum，0，sum）;行数为给出的数字个数+1(包括给出零个数字的情况)     
2>dp初始化，当前数字前的所有数字的连加和与连减查可以被确定为1，因为至少有一种方法（连加/连减）,除此之外其他都设为0  
3>
那么，状态转移方程：  
```dp[i][j]=dp[i-1][j-第i个数]+dp[i-1][j+第i个数]```
注：数组会越界，将所有越界的值都设为0
4>输入的数组为空时，有0种方法；特殊的，当目标比所有数字加起来还大或还小时，返回0种方法
```python
def findTargetSumWays(self, nums, S) -> int:
    sum = 0
    for i in nums:
        sum += i
    if sum < S:
        return 0
    dp = [[0 for i in range(sum * 2 + 1)] for i in range(len(nums) + 1)]
    dp[0][sum] = 1
    j = 0
    for i in range(1, len(nums) + 1):
        j += nums[i - 1]
        dp[i][sum - j] = dp[i][sum + j] = 1
        for k in range(sum - j, sum + 1):
            l = 0 if k - nums[i - 1] < 0 else k - nums[i - 1]
            r = 0 if k + nums[i - 1] > sum * 2 else k + nums[i - 1]
            dp[i][k] = dp[i][sum * 2 - k] = max(dp[i][k], dp[i - 1][l] + dp[i - 1][r])
    return dp[-1][sum + S]
```

