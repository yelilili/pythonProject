###[309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)    
给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
示例:

输入: [1,2,3,0,2]     
输出: 3   
解释: 对应的交易状态为:       
[买入, 卖出, 冷冻期, 买入, 卖出]

每一次的买卖与前一天的状态有关，即动态规划。  
---动态规划题目四要素---：    
1>dp定义，维度,长度    
2>dp初始化     
3>dp状态转移  
4>判空

1>二维dp：     
行：股票不同价格    
列：每天的状态     
每一天不同价格对应不同三个状态：     
①持有今天的股票    
②当前为冷冻期，即不能买当天股票也无股票可卖  
③当前非冷冻期，可买本次股票，也可以不操作   
2>第一天对应的三个状态分别为：-prices[0],0,0
    （第一天若买入，利润一定为负）     
3>三个状态对应的状态转移：  
①持有今天的股票的来源：只有昨天为非冷冻期时才可买入，dp[持有今日股票的利润]=dp[昨天非冷冻]-今天买股票花的钱 或 昨天就买了，今天不操作，dp[持有昨天的股票]   
②当前为冷冻期的来源：昨天持有股票，今日可以卖出，卖出后进入冷冻，dp[昨天持有]+今日股票票价    
③当前非冷冻期的来源：昨天为非冷冻不操作，今天依旧非冷冻dp[昨天非冷冻] 或 昨天冷冻期，今天刚过冷冻期，明日可以买，dp[昨天冷冻]       
4>没有股票可买，利润为0
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:
            return 0
        dp=[[0]*3 for i in range(len(prices))]
        dp[0][0]=-prices[0]
        for i in range(1,len(prices)):
            dp[i][0]=max(dp[i-1][0],dp[i-1][2]-prices[i])#(上次的持有不操作，上次的非冷冻这次买)->持有
            dp[i][1]=dp[i-1][0]+prices[i]#上次持有这次卖出->冷冻期
            dp[i][2]=max(dp[i-1][2],dp[i-1][1])#（上次非冷冻不操作,上次冷冻刚解冻）->非冷冻
        return max(dp[-1][1],dp[-1][2])
```